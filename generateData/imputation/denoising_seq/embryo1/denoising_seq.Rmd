---
title: "Pipleine to assess imputation: performance, cell mapping stability and others."
output:
  BiocStyle::html_document:
    code_folding: hide
    number_sections: yes
    toc: yes  
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: true
    theme: united
---


# Load dependencies and source data

```{r load_data, message=FALSE}

library(Matrix)
library(scran)
library(BiocParallel)
library(BiocNeighbors)
ncores = 4
mcparam = MulticoreParam(workers = ncores)
register(mcparam)
library(igraph)
library(reshape2)
library(knitr)
library(scater)
library(scales)
library(biomaRt)
library(batchelor)
library(irlba)
library(batchelor)
library(tibble)
library(dplyr)
library(purrr)

root.dir = "/nfs/research1/marioni/alsu/spatial/mouse_embryo/"
source(paste0(root.dir, "amScripts_mouseEmbryoFISH/core_functions.R"))

# load seq
load_embryo_8.5(dir = "cluster")
sce.seq = sce[!rownames(sce) == "Xist", sce$embryo == "embryo1"]

meta = data.frame(colData(sce.seq))
counts.cosine.seq = as.matrix( cosineNorm(assay(sce.seq, "logcounts_area")) )

# add CT
meta.CT = readRDS(paste0(root.dir, "data/8_5/source/E8.5_treeMNN_denoised.Rds"))
colnames(meta.CT)[colnames(meta.CT) == "cell"] <- "uniqueID"
meta = merge(meta, meta.CT, all.x = T, all.y = F)

# NN-graph
neigh.net = readRDS(paste0(root.dir, "data/8_5/source/E8.5_neighbourGraph_1.3.Rds"))

```

# Set up denoising function

```{r get-denoising-function, warning=FALSE}



denoisingCounts = function(counts, n.neigh, func_avg_metric, mcparam){
  vertices.neigh.net = as_ids( V(neigh.net) )
  vertices.neigh.net = intersect(vertices.neigh.net, colnames(counts))
  neigh.net = subgraph(neigh.net, vertices.neigh.net)
  short.dist = distances(neigh.net, v = vertices.neigh.net, to = vertices.neigh.net)
  denoised.counts.perCell = bplapply(colnames(counts), function(cell){
    current.CT = meta$celltype_mapped_denoised[meta$uniqueID == cell]
    
    if (sum(rownames(short.dist) == cell) == 1){
      neighbor.cells = names(which(short.dist[cell, ] <= n.neigh))
      if (!is_empty(neighbor.cells)){
        neighbor.CT = sapply(neighbor.cells, function(x) meta$celltype_mapped_denoised[meta$uniqueID == x])
        cells.sameCT = c( cell , names(neighbor.CT)[neighbor.CT == current.CT])
        if (length(cells.sameCT) > 1){
          current.counts = counts[,cells.sameCT]
          current.counts = apply(current.counts, 1, func_avg_metric)
          return(current.counts)
        } else {
          return(counts[,cell])
        }
      } else {
        return(counts[,cell])
      }
    } else {
      return(counts[,cell])
    } 
  }, BPPARAM = mcparam)
  denoised.counts.perCell = do.call(cbind, denoised.counts.perCell)
  colnames(denoised.counts.perCell) = colnames(counts)
  rownames(denoised.counts.perCell) = rownames(counts)
  return(denoised.counts.perCell)
}


```

# Get denoised counts

nn = 1-5; metrics = {mean, median, min, q25, q75, max}

```{r calculate-denoising, warning=FALSE}

n.neigh.grid = c(1:5)

counts.denoised = lapply( n.neigh.grid , function(i) {
  counts.denoised.mean = denoisingCounts(counts.cosine.seq, i, function(x){ mean(x) }, mcparam) 
  counts.denoised.min = denoisingCounts(counts.cosine.seq, i, function(x){ min(x) }, mcparam) 
  counts.denoised.q25 = denoisingCounts(counts.cosine.seq, i, function(x){ quantile(x, .25) }, mcparam)
  counts.denoised.q50 = denoisingCounts(counts.cosine.seq, i, function(x){ quantile(x, .5) }, mcparam)
  counts.denoised.q75 = denoisingCounts(counts.cosine.seq, i, function(x){ quantile(x, .75) }, mcparam) 
  counts.denoised.max = denoisingCounts(counts.cosine.seq, i, function(x){ max(x) }, mcparam) 
  current.counts.denoised = list(mean = counts.denoised.mean,
                                 min = counts.denoised.min, q25 = counts.denoised.q25, 
                                 q50 = counts.denoised.q50, q75 = counts.denoised.q75, 
                                 max = counts.denoised.max)
  return(current.counts.denoised)
})
names(counts.denoised) = paste0("nn_", n.neigh.grid)  
saveRDS(counts.denoised, file = paste0(root.dir, "data/8_5/stitching/seq_denoised_embryo1.rds"))


```







```



#Session Info

```{r sessinf}
sessionInfo()
```
