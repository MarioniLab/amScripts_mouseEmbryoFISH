---
title: "Spatial coherency"
output:
  BiocStyle::html_document:
    code_folding: hide
    number_sections: yes
    toc: yes  
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: true
    theme: united
---


# Load dependencies and source data

```{r load_data, message=FALSE}

library(Matrix)
library(scran)
library(BiocParallel)
library(BiocNeighbors)
ncores = 3
mcparam = MulticoreParam(workers = ncores)
register(mcparam)
library(igraph)
library(reshape2)
library(knitr)
library(scater)
library(scales)
library(biomaRt)
library(batchelor)
library(irlba)
library(batchelor)
library(tibble)
library(dplyr)
library(purrr)

root.dir = "/nfs/research1/marioni/alsu/spatial/mouse_embryo/"
source(paste0(root.dir, "amScripts_mouseEmbryoFISH/core_functions.R"))

# load seq embryos
load_embryo_8.5(dir = "cluster")
#load_embryo_8.5(dir = "local")
sce.seq = sce[!rownames(sce) == "Xist", ]
sce.seq = sce.seq[order(rownames(sce.seq)),order(colnames(sce.seq))]
counts.seq = as.matrix(counts(sce.seq))

# merge meta + CT annotation
meta = data.frame( colData(sce.seq))
meta.CT = readRDS(paste0(root.dir, "data/8_5/source/iterMNN_mapping_dt.Rds"))
meta = merge(meta, meta.CT, all.x = T, all.y = F)

genes = rownames(sce.seq)

# neigh.net
neigh.net.within_z = readRDS(paste0(root.dir, "data/8_5/source/E8.5_neighbourGraph_1.3.Rds"))
adjacency.list.within_z = adjacent_vertices(neigh.net.within_z, V(neigh.net.within_z), mode = "all")

neigh.net.between_z = readRDS(paste0(root.dir, "data/8_5/source/E8.5_neighbourGraph_1.Rds"))
adjacency.list.between_z = adjacent_vertices(neigh.net.within_z, V(neigh.net.within_z), mode = "all")


```

# Spatial coherence

## Within z-stacks

```{r spatial-coherency-within-z, message=FALSE, warning=FALSE}
# 
n.neigh = 2
spatial.coherency.within_z = bplapply(colnames(sce.seq), function(current.cell){
  current.CT = meta$iterMNN_stable[meta$uniqueID == current.cell]
  current.adjacency.list = adjacency.list.within_z[names(adjacency.list.within_z) == current.cell]
  if (!is_empty(current.adjacency.list)){
    if (n.neigh == 1){
      neighbor.cells = as_ids(current.adjacency.list[[1]])
    } else if (n.neigh == 2){
      neighbor.cells = as_ids(current.adjacency.list[[1]])
      second.neighbor.cells = sapply(neighbor.cells, function(x){
        current.second.adjacency.list = adjacency.list.within_z[names(adjacency.list.within_z) == x]
        return(as_ids(current.second.adjacency.list[[1]]))
      })
      neighbor.cells = unique(c(neighbor.cells, unlist(second.neighbor.cells)))
    }
    neighbor.CT = sapply(neighbor.cells, function(x) meta$iterMNN_stable[meta$uniqueID == x])
    cells.sameCT = c( names(neighbor.CT)[neighbor.CT == current.CT])
    cells.sameCT = setdiff(cells.sameCT, current.cell)
    if (length(cells.sameCT) > 1){
      current.counts.neighbors = counts.seq[,cells.sameCT] > 0
      current.counts = counts.seq[, current.cell] > 0
      current.spatial.consistency = sapply(genes, function(current.gene){
        return(mean(current.counts[current.gene] == current.counts.neighbors[current.gene,]))
      })
    }
    else if (length(cells.sameCT) == 1){
      current.counts.neighbors = counts.seq[,cells.sameCT] > 0
      current.counts = counts.seq[, current.cell] > 0
      current.spatial.consistency = sapply(genes, function(current.gene){
        return(mean(current.counts[current.gene] == current.counts.neighbors[current.gene]))
      })
        #current.n.neighbors = length(cells.sameCT)
    }
    else {
      current.spatial.consistency = rep(c(NA), times = length(genes))
      names(current.spatial.consistency) = genes
        #current.n.neighbors = 0
    }
  }
  else {
    current.spatial.consistency = rep(c(NA), times = length(genes))
    names(current.spatial.consistency) = genes
    #current.n.neighbors = 0
  }
  return(current.spatial.consistency)
}, BPPARAM = mcparam)

spatial.coherency.within_z = do.call(cbind, spatial.coherency.within_z)
colnames(spatial.coherency.within_z) = colnames(sce.seq)
saveRDS(spatial.coherency.within_z, file =  paste0( root.dir, "data/8_5/stitching/seq_spatialCoherency_withinZ.rds"))


```

## Between z-stacks

```{r spatial-coherency-between-z, message=FALSE, warning=FALSE}
# 
n.neigh = 2
spatial.coherency.between_z = bplapply(colnames(sce.seq), function(current.cell){
  current.CT = meta$iterMNN_stable[meta$uniqueID == current.cell]
  current.adjacency.list = adjacency.list.between_z[names(adjacency.list.between_z) == current.cell]
  if (!is_empty(current.adjacency.list)){
    if (n.neigh == 1){
      neighbor.cells = as_ids(current.adjacency.list[[1]])
    } else if (n.neigh == 2){
      neighbor.cells = as_ids(current.adjacency.list[[1]])
      second.neighbor.cells = sapply(neighbor.cells, function(x){
        current.second.adjacency.list = adjacency.list.between_z[names(adjacency.list.between_z) == x]
        return(as_ids(current.second.adjacency.list[[1]]))
      })
      neighbor.cells = unique(c(neighbor.cells, unlist(second.neighbor.cells)))
    }
    neighbor.CT = sapply(neighbor.cells, function(x) meta$iterMNN_stable[meta$uniqueID == x])
    cells.sameCT = c( names(neighbor.CT)[neighbor.CT == current.CT])
    cells.sameCT = setdiff(cells.sameCT, current.cell)
    if (length(cells.sameCT) > 1){
      current.counts.neighbors = counts.seq[,cells.sameCT] > 0
      current.counts = counts.seq[, current.cell] > 0
      current.spatial.consistency = sapply(genes, function(current.gene){
        return(mean(current.counts[current.gene] == current.counts.neighbors[current.gene,]))
      })
    }
    else if (length(cells.sameCT) == 1){
      current.counts.neighbors = counts.seq[,cells.sameCT] > 0
      current.counts = counts.seq[, current.cell] > 0
      current.spatial.consistency = sapply(genes, function(current.gene){
        return(mean(current.counts[current.gene] == current.counts.neighbors[current.gene]))
      })
        #current.n.neighbors = length(cells.sameCT)
    }
    else {
      current.spatial.consistency = rep(c(NA), times = length(genes))
      names(current.spatial.consistency) = genes
        #current.n.neighbors = 0
    }
  }
  else {
    current.spatial.consistency = rep(c(NA), times = length(genes))
    names(current.spatial.consistency) = genes
    #current.n.neighbors = 0
  }
  return(current.spatial.consistency)
}, BPPARAM = mcparam)

spatial.coherency.between_z = do.call(cbind, spatial.coherency.between_z)
colnames(spatial.coherency.between_z) = colnames(sce.seq)
saveRDS(spatial.coherency.between_z, file =  paste0( root.dir, "data/8_5/stitching/seq_spatialCoherency_betweenZ.rds"))


```





#Session Info

```{r sessinf}

sessionInfo()

```
